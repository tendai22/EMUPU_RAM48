# EMUPU_RAM48
A retroCPU companion board, inspired by Denno-Densetsu EMUZ80 and its related/inspired works

PIC18F, 128kB SRAMといにしえのCPUを用いて、いにしえのCPUを動作させます。Z80ピンアサインを基本にしていますが、基板上部にレトロCPUを載せた小型基板(メザニン基板)を繋ぐことで、Z80以外のさまざまなCPUに対応できるようにします。

PIC18F57Q43のCLC(Configurable Logic Cell)を活かしてCPU/SRAM制御信号を生成することで、最高パフォーマンスを目指します。そのために、アクセスタイム12nsのSRAMを使用します。48pin PICでピン数を稼いで、SPI経由でSDカードを駆動することも目標とする。

回路的には[奥江さんの作品](https://github.com/satoshiokue/SuperMEZ80)に由来しています。但し、奥江さんの作品は[EMUZ80](https://github.com/vintagechips/emuz80)基板をベースにしておりメザニン基板上でSRAMとCPUを搭載するのに対し、この試みでは、SRAMをメイン基板に移し、メザニン基板上にはCPUだけを載せるようにしています。

## コンセプト

* レトロCPUのプログラムはSRAM上に展開する。
* レトロCPUのプログラム展開はPICが行う(ブートローディング機能)。
* レトロCPUからSRAMへのアクセスは、/OE, /WEで行うが、これらの信号はPICのCLCで生成する。
* レトロCPUのI/OアクセスはPICで受ける。タイミング合わせのため、バスサイクルを延長する。
* バスサイクルの延長: Z80の場合は/WAIT信号による。68008の場合は/DTACKを使う。いずれもCLCでソフトウェア介在なしで発生する。
* I/O空間にはシリアル(Data, Status)、ディスクアクセス用のポートを置く。
* 割り込み発生とアクノレッジサイクル対応もPICが行う。

## CLCの使い方

SRAMの/OE, /WEをCLCでハード的に(ソフトを介在する必要なしに)発生する。これにより、SRAMアクセス時はソフト処理のオーバヘッドなしにZ80のメモリサイクルを実行させることができる。

I/Oアクセスは従来通り、PICがZ80のI/Oサイクルに対応する。/IORQで/WAIT信号をアサートし、I/OアクセスでCPUはアクセスを延長する。このやり方により、I/Oアクセスは時間が掛かる(数us～10数us程度)が、Z80プログラムの実行速度の大部分はメモリアクセスによるため、パフォーマンス低下の影響は小さいとしてよいだろう。

PIC側ソフトでI/O処理を行い、完了すると/BUSRQを立てて/WAITをネゲートする。CPUがI/Oサイクルを終了する(/IORQを監視している)と、/BUSRQを落としてCPUの実行を再開させる。/BUSRQをこのように使うことで、PIC側のサイクル終了処理を完了させるまでZ80を次のサイクルに入れないようにすることができる。

* CLCは3個使用する。それぞれで /OE, /WE, /WAITを発生する。
* /OE = /MREQ == 0 && /RD == 0 && /RFSH == 1
* /WE = /MREQ == 0 && /RD == 1 && /RFSH == 1
* /WAIT は/IORQの下りエッジでセットされるD-FFの/Q出力をあてる。

CLC1,2,3を使用し、それぞれの出力を、CLC1: /OE, CLC2: /WE, CLC3: /WAIT と割り当てる。

CLC1, CLC2は 4input AND, CLC3は D-FF with R/S とする。

CLC全セルの入力は最大8本で、RA/RCから4本、RB/RDから4本割り当てることができる。RE, RFからの割り当てはできない。この制約を考慮すると、
* Z80の出力, PICの入力: RA, RBに割り当てる。
* Z80の入力, PICの出力: RE(ソフト制御), RA or RB (CLC出力)

に割り当てるという原則ができる。

CLC1, CLC2の入力は、/MREQ, /RD, /RFSH であり、それぞれ RA1, RA4, RA5 に接続する。

CLC3の D-FF CLKに /IORQ を割り当てる。/IORQ を RA0に接続する。D-FF /Q出力を /WAITにつなぐ。/WAITをRB7に接続する。

以上を考慮して、Z80の制御線をPICに以下のように割り当てた(Rev.002.1)。

|PIC signal|Z80 signal|
|--|--|
|RA0|IORQ|
|RA1|MREQ|
|RA2|SRAM WE|
|RA3|CLK|
|RA4|SRAM OE|
|RA5|RD|
|RB7|WAIT|
|RB6|TEST(ソフト駆動用)|
|RB5|M1|
|RB4|RFSH|
|RE0|BUSRQ|
|RE1|RESET|
|RE2|INT|

RB0-3はSDカード接続用に割り当てた。

> Z80版では/RDが/MREQの下りエッジよりも先に確定することを前提としている。データシート的にはこの前提が成立するかどうか不明である。この前提が成立しない場合、リードサイクルの最初に /WEに一瞬グリッジが発生する可能性がある。このグリッジによりSRAM中のデータが破壊される可能性がある。ライトサイクルは本来/WR信号でタイミングを取る。この場合、RD7に/WR信号を繋いで、/WE信号のゲート(CLC2)入力に/WR信号を入れることになる。

## ブートローディング

SRAMのアドレスバスにPICのRD0-7, RF0-7を割り当てできている。よって、任意の位置にプログラムを転送することができる。PICからSRAMへの書き込みは、
* アドレスをRD, RFに出力し、
* データをRCに出力し、
* /WEをアサートし、ネゲートする

ことで実現できる。

> PICがアドレスバスにピン割り当てできない場合は、リセット解除後のメモリリードサイクルを捕まえて、0x21, (デスティネーション下位), (デスティネーション上位), 0x36, (書き込みバイト１バイト目), 0x23, 0x36, (書き込みバイト2バイト目), 0x23, 0x36, ... と順次バイトを置いてゆくことでSRAMにデータを転送することができる(「命令置き」)。
